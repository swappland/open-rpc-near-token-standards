
// Code generated by zane generator DO NOT EDIT.
import { RequestManager, PostMessageWindowTransport, PostMessageIframeTransport, WebSocketTransport, HTTPTransport, Client, JSONRPCError } from "@open-rpc/client-js";
import _ from "lodash";
import { OpenrpcDocument as OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator, MethodNotFoundError } from "@open-rpc/schema-utils-js";
import { Account, Near, Contract} from "near-api-js";
import BN from "bn.js"

export type Integer2AHOqbcQ = number;
export type NullQu0Arl1F = null;
/**
 *
 * AccountId for the near account
 *
 */
export type AccountId = string;
export type AccountIds = [AccountId];
export type OneOfAccountIdsNullQu0Arl1F7IRLif60 = NullQu0Arl1F | AccountIds;
/**
 *
 * U128 integer as string
 *
 */
export type U128 = string;
/**
 *
 * Token identifier that corresponds to an id
 *
 */
export type TokenId = string;
/**
 *
 * ex. Parcel #5055
 *
 */
export type NFTTokenMetadataTitle = string;
/**
 *
 * free-form description
 *
 */
export type NFTTokenMetadataDesc = string;
/**
 *
 * URL to associated media, preferably to decentralized, content-addressed storage
 *
 */
export type NFTTokenMetadataMedia = string;
/**
 *
 * Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
 *
 */
export type NFTTokenMetadataMediaHash = string;
/**
 *
 * When token was issued or minted, Unix epoc in milliseconds
 *
 */
export type NFTokenMetadataIssuedAt = string;
/**
 *
 * When token expires, Unix epoch in milliseconds
 *
 */
export type NFTokenMetadataExpiresAt = string;
/**
 *
 * When token starts being valid, Unix epoch in milliseconds
 *
 */
export type NFTokenMetadataStartsAt = string;
/**
 *
 * When token was last updated, Unix epoch in milliseconds
 *
 */
export type NFTokenMetadataUpdatedAt = string;
/**
 *
 * Anything extra the MT wants to store on-chain. Can be stringified JSON.
 *
 */
export type NFTokenMetadataExtra = string;
/**
 *
 * URL to an off-chain JSON file with more info.
 *
 */
export type NFTokenMetadataReference = string;
/**
 *
 * Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
 *
 */
export type NFTokenMetadataReferenceHash = string;
export interface NFTTokenMetadata {
  title?: NFTTokenMetadataTitle;
  description?: NFTTokenMetadataDesc;
  media?: NFTTokenMetadataMedia;
  media_hash?: NFTTokenMetadataMediaHash;
  issued_at?: NFTokenMetadataIssuedAt;
  expires_at?: NFTokenMetadataExpiresAt;
  starts_at?: NFTokenMetadataStartsAt;
  updated_at?: NFTokenMetadataUpdatedAt;
  extra?: NFTokenMetadataExtra;
  reference?: NFTokenMetadataReference;
  reference_hash?: NFTokenMetadataReferenceHash;
  [k: string]: any;
}
/**
 *
 * expected approval ID. A number smaller than 2^53
 *
 */
export type ApprovalId = number;
export interface ApprovalsObject {
  [k: string]: any;
}
export interface NFTToken {
  token_id: TokenId;
  owner_id: AccountId;
  metadata?: NFTTokenMetadata;
  approved_account_ids?: ApprovalsObject;
  [k: string]: any;
}
/**
 *
 * ex. 'Silver Swords' or 'Metaverse 3'
 *
 */
export type NFTContractMetadataName = string;
/**
 *
 * ex. MOCHI
 *
 */
export type NFTContractMetadataSymbol = string;
/**
 *
 * essentially a version like nft-1.0.0
 *
 */
export type NFTContractMetadataSpec = string;
/**
 *
 * Data URL
 *
 */
export type NFTContractMetadataIcon = string;
/**
 *
 * number of decimals for the token useful for FT related tokens
 *
 */
export type NFTContractMetadataDecimals = string;
/**
 *
 * entralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
 *
 */
export type NFTContractMetadataBaseUri = string;
/**
 *
 * URL to a JSON file with more info
 *
 */
export type NFTContractMetadataReference = string;
/**
 *
 * Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
 *
 */
export type NFTContractMetadataReferenceHash = string;
/**
 *
 * number of copies of this set of metadata in existence when token was minted.
 *
 */
export type NFTContractMetadataCopies = number;
export interface RoyaltyMap {
  [k: string]: any;
}
/**
 *
 * A message to describe an operation
 *
 */
export type Memo = string;
/**
 *
 * message for receiving contracts
 *
 */
export type Msg = string;
export type U32 = number;
export type UnorderedSetOfOneOfAccountIdsNullQu0Arl1F7IRLif60Atp7IkGI = [OneOfAccountIdsNullQu0Arl1F7IRLif60];
/**
 *
 * U64 integer as string
 *
 */
export type U64 = string;
/**
 *
 * PaginationLimit
 *
 */
export type PaginationLimit = number;
export type ContractRoyalty = number;
export interface NFTPayout {
  [k: string]: any;
}
export type NFTTokens = [NFTToken];
/**
 *
 * Metadata for tokens at class level
 *
 */
export interface NFTContractMetadata {
  name: NFTContractMetadataName;
  symbol: NFTContractMetadataSymbol;
  spec: NFTContractMetadataSpec;
  icon?: NFTContractMetadataIcon;
  decimals?: NFTContractMetadataDecimals;
  base_uri?: NFTContractMetadataBaseUri;
  reference?: NFTContractMetadataReference;
  reference_hash?: NFTContractMetadataReferenceHash;
  copies?: NFTContractMetadataCopies;
  [k: string]: any;
}
export type BooleanVyG3AETh = boolean;
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */
export type AnyOfTokenIdRoyaltyMapAccountIdTokenIdApprovalIdMemoAccountIdTokenIdApprovalIdMemoMsgTokenIdU128U32AccountIdTokenIdU128U32ApprovalIdAccountIdAccountIdAccountIdTokenIdUnorderedSetOfOneOfAccountIdsNullQu0Arl1F7IRLif60Atp7IkGITokenIdU64PaginationLimitAccountIdU64PaginationLimitAccountIdTokenIdAccountIdMsgTokenIdAccountIdTokenIdTokenIdAccountIdApprovalIdNullQu0Arl1FContractRoyaltyNullQu0Arl1FU128NFTPayoutNFTPayoutU128NFTTokenNFTTokensNFTTokensNFTContractMetadataU128U128NullQu0Arl1FNullQu0Arl1FNullQu0Arl1FBooleanVyG3AETh = TokenId | RoyaltyMap | AccountId | ApprovalId | Memo | Msg | U128 | U32 | UnorderedSetOfOneOfAccountIdsNullQu0Arl1F7IRLif60Atp7IkGI | U64 | PaginationLimit | NullQu0Arl1F | ContractRoyalty | NFTPayout | NFTToken | NFTTokens | NFTContractMetadata | BooleanVyG3AETh;
export type SetTokenRoyalty = (token_id: TokenId, royalty: RoyaltyMap) => Promise<NullQu0Arl1F>;
export type GetContractRoyalty = () => Promise<ContractRoyalty>;
export type NftTransfer = (receiver_id: AccountId, token_id: TokenId, approval_id?: ApprovalId, memo?: Memo) => Promise<NullQu0Arl1F>;
export type NftTransferCall = (receiver_id: AccountId, token_id: TokenId, approval_id?: ApprovalId, memo?: Memo, msg?: Msg) => Promise<U128>;
export type NftPayout = (token_id: TokenId, balance: U128, max_len_payout: U32) => Promise<NFTPayout>;
export type NftTransferPayout = (receiver_id: AccountId, token_id: TokenId, balance: U128, max_len_payout: U32, approval_id?: ApprovalId) => Promise<NFTPayout>;
export type NftResolveTransfer = (sender_id: AccountId, previous_owner_id: AccountId, receiver_id: AccountId, token_id: TokenId, approved_account_ids?: UnorderedSetOfOneOfAccountIdsNullQu0Arl1F7IRLif60Atp7IkGI) => Promise<U128>;
export type NftToken = (token_id: TokenId) => Promise<NFTToken>;
export type NftTokens = (from_index: U64, limit: PaginationLimit) => Promise<NFTTokens>;
export type NftTokensForOwner = (account_id: AccountId, from_index: U64, limit: PaginationLimit) => Promise<NFTTokens>;
export type NftMetadata = () => Promise<NFTContractMetadata>;
export type NftTotalSupply = () => Promise<U128>;
export type NftSupplyForOwner = (account_id: AccountId) => Promise<U128>;
export type NftApprove = (token_id: TokenId, account_id: AccountId, msg?: Msg) => Promise<NullQu0Arl1F>;
export type NftRevoke = (token_id: TokenId, account_id: AccountId) => Promise<NullQu0Arl1F>;
export type NftRevokeAll = (token_id: TokenId) => Promise<NullQu0Arl1F>;
export type NftIsApproved = (token_id: TokenId, approved_account_id: AccountId, approval_ids: ApprovalId) => Promise<BooleanVyG3AETh>;

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTSetTokenRoyalty = [...Parameters<SetTokenRoyalty>, ChangeMethodOptions?]
  type RTSetTokenRoyalty = ReturnType<SetTokenRoyalty>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetContractRoyalty = [...Parameters<GetContractRoyalty>, ChangeMethodOptions?]
  type RTGetContractRoyalty = ReturnType<GetContractRoyalty>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftTransfer = [...Parameters<NftTransfer>, ChangeMethodOptions?]
  type RTNftTransfer = ReturnType<NftTransfer>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftTransferCall = [...Parameters<NftTransferCall>, ChangeMethodOptions?]
  type RTNftTransferCall = ReturnType<NftTransferCall>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftPayout = [...Parameters<NftPayout>, ChangeMethodOptions?]
  type RTNftPayout = ReturnType<NftPayout>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftTransferPayout = [...Parameters<NftTransferPayout>, ChangeMethodOptions?]
  type RTNftTransferPayout = ReturnType<NftTransferPayout>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftResolveTransfer = [...Parameters<NftResolveTransfer>, ChangeMethodOptions?]
  type RTNftResolveTransfer = ReturnType<NftResolveTransfer>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftToken = [...Parameters<NftToken>, ChangeMethodOptions?]
  type RTNftToken = ReturnType<NftToken>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftTokens = [...Parameters<NftTokens>, ChangeMethodOptions?]
  type RTNftTokens = ReturnType<NftTokens>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftTokensForOwner = [...Parameters<NftTokensForOwner>, ChangeMethodOptions?]
  type RTNftTokensForOwner = ReturnType<NftTokensForOwner>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftMetadata = [...Parameters<NftMetadata>, ChangeMethodOptions?]
  type RTNftMetadata = ReturnType<NftMetadata>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftTotalSupply = [...Parameters<NftTotalSupply>, ChangeMethodOptions?]
  type RTNftTotalSupply = ReturnType<NftTotalSupply>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftSupplyForOwner = [...Parameters<NftSupplyForOwner>, ChangeMethodOptions?]
  type RTNftSupplyForOwner = ReturnType<NftSupplyForOwner>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftApprove = [...Parameters<NftApprove>, ChangeMethodOptions?]
  type RTNftApprove = ReturnType<NftApprove>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftRevoke = [...Parameters<NftRevoke>, ChangeMethodOptions?]
  type RTNftRevoke = ReturnType<NftRevoke>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftRevokeAll = [...Parameters<NftRevokeAll>, ChangeMethodOptions?]
  type RTNftRevokeAll = ReturnType<NftRevokeAll>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftIsApproved = [...Parameters<NftIsApproved>, ChangeMethodOptions?]
  type RTNftIsApproved = ReturnType<NftIsApproved>


export interface Options {
    account: Account;
    contractId: string;
}

export type NearNumber = BN | string | number;

export interface ChangeMethodOptions {
  gas?: NearNumber 
  amount?: NearNumber
}

const isMetaObject = (x: any): boolean => {
  if(x && (x.gas || x.amount)) return true
  return false
}

export class NftStandard {
  public static openrpcDocument: OpenRPC = {"openrpc":"1.0.0","info":{"title":"NftStandard","version":"0.0.0-development"},"methods":[{"name":"set_token_royalty","summary":"Set token royalty for the token_id","description":"Set token royalty for the token_id","tags":[{"name":"change","description":"change method"}],"params":[{"name":"token_id","summary":"Set the token_id for the royalty","description":"Set the token_id for the royalty","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"royalty","summary":"Set the royalty amount for each account id payout","description":"Set the royalty amount for each account id payout","schema":{"title":"RoyaltyMap","type":"object","properties":{},"additionalProperties":{"type":"integer","title":"integer_2aHOqbcQ"}},"required":true}],"result":{"name":"NftSimpleRoyaltyResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"get_contract_royalty","summary":"Get royalty for the contract","description":"Get royalty for the contract","tags":[{"name":"view","description":"View only methods"}],"params":[],"result":{"name":"NftSimpleGetContractRoyaltyResult","summary":"Contract royalty payout","description":"Contract royalty payout","schema":{"title":"ContractRoyalty","type":"integer"}}},{"name":"nft_transfer","summary":"Transfers tokens from one account to another","description":"Transfer tokens from one account to another. A basic token transfer. Transfer a token or tokens given a token_id. The token id can correspond to either a NonFungibleToken or FungibleToken  - this is differentiated by the implementation.","tags":[{"name":"change","description":"change method"}],"params":[{"name":"receiver_id","summary":"Receiving account id","description":"The valid NEAR account receiving the token","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"The TokenId to transfer","description":"The TokenId to transfer","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"approval_id","summary":"Expected approval ID","description":"Expected approval ID. A number smaller than 2^53, and therefore representable as JSON.","schema":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"required":false},{"name":"memo","summary":"Memo message to describe operation","description":"For use cases that may benefit from indexing or providing information for a transfer","schema":{"title":"Memo","description":"A message to describe an operation","type":"string"},"required":false}],"result":{"name":"NFTTransferResult","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"nft_transfer_call","description":"Transfer tokens from one account to another contract. Transfer token/s and call a method on a receiver contract. A successful workflow will end in a success execution outcome to the callback on the MultiToken contract at the method `mt_resolve_transfer`. You can think of this as being similar to attaching NEAR tokens as a `deposit` to a function call. It allows you to attach any FungibleToken or NonFungibleToken in a call to a receiver contract.  ","summary":"Transfers tokens from one account to another contract","tags":[{"name":"change","description":"change method"}],"params":[{"name":"receiver_id","summary":"Receiving account id","description":"The valid NEAR account receiving the token","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"The TokenId to transfer","description":"The TokenId to transfer","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"approval_id","summary":"Expected approval ID","description":"Expected approval ID. A number smaller than 2^53, and therefore representable as JSON.","schema":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"required":false},{"name":"memo","summary":"Memo message to describe operation","description":"For use cases that may benefit from indexing or providing information for a transfer","schema":{"title":"Memo","description":"A message to describe an operation","type":"string"},"required":false},{"name":"msg","summary":"Specifies information for the receiving contract","description":"It specifies information needed by the receiving contract in order to properly handle the transfer. Can indicate both a function to call and the parameters to pass to that function.","schema":{"title":"Msg","description":"message for receiving contracts","type":"string"},"required":false}],"result":{"name":"NFTransferCallResult","summary":"The amount optionally returned to sender","description":"The amount returned to the sender, if resolve implmented","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":false}},{"name":"nft_payout","summary":"Retuns the `Payout` struct for a given `token_id` and `balance`","description":"Given a `token_id` and NEAR-denominated balance, return the `Payout` struct for the given token. Panic if the length of the payout exceeds  `max_len_payout.`","tags":[{"name":"view","description":"View only methods"}],"paramStructure":"by-name","params":[{"name":"token_id","summary":"The TokenId to transfer","description":"The TokenId to transfer","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"balance","summary":"The amount for the nft contract to determine payout","description":"The amount for the nft contract to determine payout","schema":{"title":"U128","type":"string","description":"U128 integer as string"}},{"name":"max_len_payout","summary":"The maximum number of accounts to pay out","description":"The maximum number of accounts that can be paid out","schema":{"title":"U32","type":"integer","minimum":0}}],"result":{"name":"NFTPayoutResult","schema":{"title":"NFTPayout","type":"object","properties":{},"additionalProperties":{"title":"U128","type":"string","description":"U128 integer as string"}}}},{"name":"nft_transfer_payout","summary":"Transfers tokens from one account to another with royalty payout","description":"Transfer tokens from one account to another with royalty payout calculation. Calling contract receives resulting payout computation","tags":[{"name":"change","description":"change method"}],"paramStructure":"by-name","params":[{"name":"receiver_id","summary":"Receiving account id","description":"The valid NEAR account receiving the token","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"The TokenId to transfer","description":"The TokenId to transfer","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"balance","summary":"The amount for the nft contract to determine payout","description":"The amount for the nft contract to determine payout","schema":{"title":"U128","type":"string","description":"U128 integer as string"}},{"name":"max_len_payout","summary":"The maximum number of accounts to pay out","description":"The maximum number of accounts that can be paid out","schema":{"title":"U32","type":"integer","minimum":0}},{"name":"approval_id","summary":"Expected approval ID","description":"Expected approval ID. A number smaller than 2^53, and therefore representable as JSON.","schema":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"required":false}],"result":{"name":"NFTTransferPayout","schema":{"title":"NFTPayout","type":"object","properties":{},"additionalProperties":{"title":"U128","type":"string","description":"U128 integer as string"}}}},{"name":"nft_resolve_transfer","summary":"Used when MultiTokens are transferred using `mt_transfer_call`","description":"Used when MultiTokens are transferred using `mt_transfer_call`. This is the method that's called after `mt_on_transfer` implemented on the multitoken contract","tags":[{"name":"change","description":"change method"}],"params":[{"name":"sender_id","summary":"sender of `nft_transfer_call`","description":"sender of `nft_transfer_call`","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"previous_owner_id","summary":"The account that owned the tokens prior to it being transferred with `mt_transfer_call`","description":"The account that owned the tokens prior to it being transferred","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"receiver_id","summary":"The `receiver_id` argument of `nft_transfer_call`","description":"The `receiver_id` argument of `nft_transfer_call`, the account being transfered to","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"The `token_ids` argument given to `nft_transfer_call`","description":"The `token_ids` argument given to `nft_transfer_call`","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},{"name":"approved_account_ids","summary":"Approved accounts in case of revert.","description":"Approved accounts in case of revert. In this case it may be multiple sets of approvals . If specified the length and order must correspond to token_ids","schema":{"type":"array","items":[{"oneOf":[{"type":"null","title":"null_Qu0Arl1F"},{"title":"AccountIds","type":"array","items":[{"title":"AccountId","type":"string","description":"AccountId for the near account"}]}],"title":"oneOf_AccountIds_null_Qu0Arl1F_7IRLif60"}],"title":"unorderedSetOf_oneOf_AccountIds_null_Qu0Arl1F_7IRLif60Atp7IkGI"},"required":false}],"result":{"name":"NftResolveTransferResult","summary":"Returns the amount of how many total tokens were spent by `sender_id`, corresponding to the `token_id`.Returns a vector of  amounts for the tokens that should be returned to `sender_id`","description":"Returns the amount of how many total tokens were spent by `sender_id`, corresponding to the `token_id`.Returns a vector of  amounts for the tokens that should be returned to `sender_id`","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true}},{"name":"nft_token","summary":"Get a list of all tokens. ","description":"Get a list of all tokens. Returning a list of `NFToken` with respect to pagination.","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"token_id","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}}],"result":{"name":"NFTokenResult","summary":"Token description given token id","description":"Token description given token id, or null if token doesn't exist","schema":{"title":"NFTToken","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}},"approved_account_ids":{"title":"ApprovalsObject","type":"object","properties":{},"additionalProperties":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"}}},"required":["token_id","owner_id"]},"required":true}},{"name":"nft_tokens","summary":"Get a list of all tokens. ","description":"Get a list of all tokens. Returning a list of `NFToken` with respect to pagination.","tags":[{"name":"view","description":"View only methods"},{"name":"EnumerationExtension","description":"The optional Enumeration standard for MultiToken"}],"params":[{"name":"from_index","schema":{"title":"U64","type":"string","description":"U64 integer as string"}},{"name":"limit","schema":{"title":"PaginationLimit","description":"PaginationLimit","type":"number"}}],"result":{"name":"NFTokensResult","summary":"List of all tokens in the contract truncated by the pagination limits.","description":"List of all tokens in the contract truncated by the pagination limits. An empty array represents no tokens","schema":{"title":"NFTTokens","type":"array","items":[{"title":"NFTToken","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}},"approved_account_ids":{"title":"ApprovalsObject","type":"object","properties":{},"additionalProperties":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"}}},"required":["token_id","owner_id"]}]},"required":true}},{"name":"nft_tokens_for_owner","summary":"Get a list of all tokens owned by the account specified. ","description":"Get a list of all tokens owned by the account specified. Returning a list of `NFToken` with respect to pagination.","tags":[{"name":"view","description":"View only methods"},{"name":"EnumerationExtension","description":"The optional Enumeration standard for MultiToken"}],"params":[{"name":"account_id","summary":"the owner account id","description":"the owner account id","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"from_index","summary":"a string representing an unsigned 128-bit integer, representing the starting index of tokens to return","description":"a string representing an unsigned 128-bit integer, representing the starting index of tokens to return","schema":{"title":"U64","type":"string","description":"U64 integer as string"}},{"name":"limit","summary":"the maximum number of tokens to return","description":"the maximum number of tokens to return","schema":{"title":"PaginationLimit","description":"PaginationLimit","type":"number"}}],"result":{"name":"NFTokensResult","summary":"List of all tokens in the contract truncated by the pagination limits.","description":"List of all tokens in the contract truncated by the pagination limits. An empty array represents no tokens","schema":{"title":"NFTTokens","type":"array","items":[{"title":"NFTToken","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}},"approved_account_ids":{"title":"ApprovalsObject","type":"object","properties":{},"additionalProperties":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"}}},"required":["token_id","owner_id"]}]},"required":true}},{"name":"nft_metadata","summary":"Get contract level metadata","description":"Get contract level metadata","tags":[{"name":"view","description":"View only methods"},{"name":"MetadataExtension","description":"Metadata Extension for representing token meta data"}],"params":[],"result":{"name":"NFTContractMetadataResult","summary":"Contract metadata","schema":{"title":"NFTContractMetadata","description":"Metadata for tokens at class level","type":"object","properties":{"name":{"title":"NFTContractMetadataName","type":"string","description":"ex. 'Silver Swords' or 'Metaverse 3'"},"symbol":{"title":"NFTContractMetadataSymbol","type":"string","description":"ex. MOCHI"},"spec":{"title":"NFTContractMetadataSpec","type":"string","description":"essentially a version like nft-1.0.0"},"icon":{"title":"NFTContractMetadataIcon","type":"string","description":"Data URL"},"decimals":{"title":"NFTContractMetadataDecimals","type":"string","description":"number of decimals for the token useful for FT related tokens"},"base_uri":{"title":"NFTContractMetadataBaseUri","type":"string","description":"entralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs"},"reference":{"title":"NFTContractMetadataReference","type":"string","description":"URL to a JSON file with more info"},"reference_hash":{"title":"NFTContractMetadataReferenceHash","type":"string","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."},"copies":{"title":"NFTContractMetadataCopies","type":"number","description":"number of copies of this set of metadata in existence when token was minted."}},"required":["name","symbol","spec"]}}},{"name":"nft_total_supply","summary":"Get total number of tokens in the contract","description":"Get total number of tokens in the contract","tags":[{"name":"view","description":"View only methods"},{"name":"EnumerationExtension","description":"The optional Enumeration standard for MultiToken"}],"params":[],"result":{"name":"NFTTokensSupply","summary":"Total supply of nft tokens owned by an account","description":"Total supply of nft tokens owned by an account. Returns the number of non-fungible tokens owned by given `account_id` as","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true}},{"name":"nft_supply_for_owner","summary":"Get number of tokens owned by a given account","description":"Get number of tokens owned by a given account","tags":[{"name":"view","description":"View only methods"},{"name":"EnumerationExtension","description":"The optional Enumeration standard for MultiToken"}],"params":[{"summary":"","description":"","name":"account_id","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true}],"result":{"name":"NFTTokensOwnerSupply","summary":"Total supply of nft tokens owned by an account","description":"Total supply of nft tokens owned by an account. Returns the number of non-fungible tokens owned by given `account_id` as","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true}},{"name":"nft_approve","summary":"Add an approved account for a specific set of tokens","description":"Add an approved account for a specific set of tokens","tags":[{"name":"change","description":"change method"},{"name":"ApprovalManagement","description":"Approval Management Extension"}],"params":[{"name":"token_id","summary":"The token ids for which to add an approval","description":"The token ids for which to add an approval","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"account_id","summary":"The account to add to approvals","description":"The account to add to approvals","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"msg","summary":"optional string to be passed to `mt_on_approve`","description":"optional string to be passed to `mt_on_approve`","schema":{"title":"Msg","description":"message for receiving contracts","type":"string"},"required":false}],"result":{"name":"NftApproveResult","summary":"Void, if no `msg` given.","description":"Void, if no `msg` given. Otherwise, returns promise call to `mt_on_approve`, which can resolve with whatever it wants.","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"nft_revoke","summary":"Revoke an approved account for a specific token","description":"Revoke an approved account for a specific token","tags":[{"name":"change","description":"change method"},{"name":"ApprovalManagement","description":"Approval Management Extension"}],"params":[{"name":"token_id","summary":"The token id for which to revoke approvals","description":"The token id for which to revoke approvals","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"account_id","summary":"The account to revoke from approvals","description":"The account to revoke from approvals","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"}}],"result":{"name":"MtRevokeResult","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"nft_revoke_all","summary":"Revoke all approved accounts for a specific token.","description":"Revoke all approved accounts for a specific token.  Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes","tags":[{"name":"change","description":"change method"},{"name":"ApprovalManagement","description":"Approval Management Extension"}],"params":[{"name":"token_id","summary":"The token id for which to revoke all approvals","description":"The token ids for which to revoke all approvals","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true}],"result":{"name":"MtRevokeAllResult","schema":{"type":"null","title":"null_Qu0Arl1F"},"required":true}},{"name":"nft_is_approved","summary":"Check if tokens are approved for transfer by a given account, optionally checking approval_id","description":"Check if tokens are approved for transfer by a given account, optionally checking approval_id","tags":[{"name":"view","description":"View only methods"},{"name":"ApprovalManagement","description":"Approval Management Extension"}],"params":[{"name":"token_id","summary":"The token ids for which to check approval","description":"The token ids for which to check approval","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"approved_account_id","summary":"the account to check the existence of in `approvals`","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"approval_ids","summary":"an optional approval ID to check against current approval ID for given account","schema":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"}}],"result":{"name":"NftApprovedResult","summary":"returns state of the approval for tokens given the approved_acccount_id","description":"returns state of the approval for tokens given the approved_acccount_id","schema":{"type":"boolean","title":"boolean_vyG3AETh"}}}]} ;
  public contract: Contract;
  private validator: MethodCallValidator;

  constructor(options: Options) {
    const {account, contractId} = options;
    this.validator = new MethodCallValidator(NftStandard.openrpcDocument);
    const changeMethods:string[] = [
      "set_token_royalty",
      "nft_transfer",
      "nft_transfer_call",
      "nft_transfer_payout",
      "nft_resolve_transfer",
      "nft_approve",
      "nft_revoke",
      "nft_revoke_all",
    ] 

    const viewMethods:string[] = [
      "get_contract_royalty",
      "nft_payout",
      "nft_token",
      "nft_tokens",
      "nft_tokens_for_owner",
      "nft_metadata",
      "nft_total_supply",
      "nft_supply_for_owner",
      "nft_is_approved",
    ]
    this.contract = new Contract(account,contractId, {changeMethods, viewMethods})
  }

  

  /**
   * Set token royalty for the token_id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public set_token_royalty(token_id: TokenId, royalty: RoyaltyMap, options?: ChangeMethodOptions): RTSetTokenRoyalty { 
    //return this.request("set_token_royalty", params);
    const paramNames:string[] = [  
      "token_id", 
      "royalty",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).set_token_royalty({args: paramByName, ...options}) as RTSetTokenRoyalty 
    }

    return (this.contract as any).set_token_royalty({args: paramByName}) as RTSetTokenRoyalty 
  }
  

  /**
   * Get royalty for the contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_contract_royalty(): RTGetContractRoyalty { 
    //return this.request("get_contract_royalty", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_contract_royalty({args: paramByName, ...options}) as RTGetContractRoyalty 
    }

    return (this.contract as any).get_contract_royalty(paramByName) as RTGetContractRoyalty 
    
  }
  

  /**
   * Transfers tokens from one account to another
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_transfer(receiver_id: AccountId, token_id: TokenId, approval_id?: ApprovalId, memo?: Memo, options?: ChangeMethodOptions): RTNftTransfer { 
    //return this.request("nft_transfer", params);
    const paramNames:string[] = [  
      "receiver_id", 
      "token_id", 
      "approval_id", 
      "memo",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_transfer({args: paramByName, ...options}) as RTNftTransfer 
    }

    return (this.contract as any).nft_transfer({args: paramByName}) as RTNftTransfer 
  }
  

  /**
   * Transfers tokens from one account to another contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_transfer_call(receiver_id: AccountId, token_id: TokenId, approval_id?: ApprovalId, memo?: Memo, msg?: Msg, options?: ChangeMethodOptions): RTNftTransferCall { 
    //return this.request("nft_transfer_call", params);
    const paramNames:string[] = [  
      "receiver_id", 
      "token_id", 
      "approval_id", 
      "memo", 
      "msg",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_transfer_call({args: paramByName, ...options}) as RTNftTransferCall 
    }

    return (this.contract as any).nft_transfer_call({args: paramByName}) as RTNftTransferCall 
  }
  

  /**
   * Retuns the `Payout` struct for a given `token_id` and `balance`
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_payout(token_id: TokenId, balance: U128, max_len_payout: U32): RTNftPayout { 
    //return this.request("nft_payout", params);
    const paramNames:string[] = [  
      "token_id", 
      "balance", 
      "max_len_payout",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_payout({args: paramByName, ...options}) as RTNftPayout 
    }

    return (this.contract as any).nft_payout(paramByName) as RTNftPayout 
    
  }
  

  /**
   * Transfers tokens from one account to another with royalty payout
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_transfer_payout(receiver_id: AccountId, token_id: TokenId, balance: U128, max_len_payout: U32, approval_id?: ApprovalId, options?: ChangeMethodOptions): RTNftTransferPayout { 
    //return this.request("nft_transfer_payout", params);
    const paramNames:string[] = [  
      "receiver_id", 
      "token_id", 
      "balance", 
      "max_len_payout", 
      "approval_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_transfer_payout({args: paramByName, ...options}) as RTNftTransferPayout 
    }

    return (this.contract as any).nft_transfer_payout({args: paramByName}) as RTNftTransferPayout 
  }
  

  /**
   * Used when MultiTokens are transferred using `mt_transfer_call`
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_resolve_transfer(sender_id: AccountId, previous_owner_id: AccountId, receiver_id: AccountId, token_id: TokenId, approved_account_ids?: UnorderedSetOfOneOfAccountIdsNullQu0Arl1F7IRLif60Atp7IkGI, options?: ChangeMethodOptions): RTNftResolveTransfer { 
    //return this.request("nft_resolve_transfer", params);
    const paramNames:string[] = [  
      "sender_id", 
      "previous_owner_id", 
      "receiver_id", 
      "token_id", 
      "approved_account_ids",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_resolve_transfer({args: paramByName, ...options}) as RTNftResolveTransfer 
    }

    return (this.contract as any).nft_resolve_transfer({args: paramByName}) as RTNftResolveTransfer 
  }
  

  /**
   * Get a list of all tokens. 
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_token(token_id: TokenId): RTNftToken { 
    //return this.request("nft_token", params);
    const paramNames:string[] = [  
      "token_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_token({args: paramByName, ...options}) as RTNftToken 
    }

    return (this.contract as any).nft_token(paramByName) as RTNftToken 
    
  }
  

  /**
   * Get a list of all tokens. 
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_tokens(from_index: U64, limit: PaginationLimit): RTNftTokens { 
    //return this.request("nft_tokens", params);
    const paramNames:string[] = [  
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_tokens({args: paramByName, ...options}) as RTNftTokens 
    }

    return (this.contract as any).nft_tokens(paramByName) as RTNftTokens 
    
  }
  

  /**
   * Get a list of all tokens owned by the account specified. 
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_tokens_for_owner(account_id: AccountId, from_index: U64, limit: PaginationLimit): RTNftTokensForOwner { 
    //return this.request("nft_tokens_for_owner", params);
    const paramNames:string[] = [  
      "account_id", 
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_tokens_for_owner({args: paramByName, ...options}) as RTNftTokensForOwner 
    }

    return (this.contract as any).nft_tokens_for_owner(paramByName) as RTNftTokensForOwner 
    
  }
  

  /**
   * Get contract level metadata
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_metadata(): RTNftMetadata { 
    //return this.request("nft_metadata", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_metadata({args: paramByName, ...options}) as RTNftMetadata 
    }

    return (this.contract as any).nft_metadata(paramByName) as RTNftMetadata 
    
  }
  

  /**
   * Get total number of tokens in the contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_total_supply(): RTNftTotalSupply { 
    //return this.request("nft_total_supply", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_total_supply({args: paramByName, ...options}) as RTNftTotalSupply 
    }

    return (this.contract as any).nft_total_supply(paramByName) as RTNftTotalSupply 
    
  }
  

  /**
   * Get number of tokens owned by a given account
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_supply_for_owner(account_id: AccountId): RTNftSupplyForOwner { 
    //return this.request("nft_supply_for_owner", params);
    const paramNames:string[] = [  
      "account_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_supply_for_owner({args: paramByName, ...options}) as RTNftSupplyForOwner 
    }

    return (this.contract as any).nft_supply_for_owner(paramByName) as RTNftSupplyForOwner 
    
  }
  

  /**
   * Add an approved account for a specific set of tokens
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_approve(token_id: TokenId, account_id: AccountId, msg?: Msg, options?: ChangeMethodOptions): RTNftApprove { 
    //return this.request("nft_approve", params);
    const paramNames:string[] = [  
      "token_id", 
      "account_id", 
      "msg",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_approve({args: paramByName, ...options}) as RTNftApprove 
    }

    return (this.contract as any).nft_approve({args: paramByName}) as RTNftApprove 
  }
  

  /**
   * Revoke an approved account for a specific token
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_revoke(token_id: TokenId, account_id: AccountId, options?: ChangeMethodOptions): RTNftRevoke { 
    //return this.request("nft_revoke", params);
    const paramNames:string[] = [  
      "token_id", 
      "account_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_revoke({args: paramByName, ...options}) as RTNftRevoke 
    }

    return (this.contract as any).nft_revoke({args: paramByName}) as RTNftRevoke 
  }
  

  /**
   * Revoke all approved accounts for a specific token.
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_revoke_all(token_id: TokenId, options?: ChangeMethodOptions): RTNftRevokeAll { 
    //return this.request("nft_revoke_all", params);
    const paramNames:string[] = [  
      "token_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_revoke_all({args: paramByName, ...options}) as RTNftRevokeAll 
    }

    return (this.contract as any).nft_revoke_all({args: paramByName}) as RTNftRevokeAll 
  }
  

  /**
   * Check if tokens are approved for transfer by a given account, optionally checking approval_id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_is_approved(token_id: TokenId, approved_account_id: AccountId, approval_ids: ApprovalId): RTNftIsApproved { 
    //return this.request("nft_is_approved", params);
    const paramNames:string[] = [  
      "token_id", 
      "approved_account_id", 
      "approval_ids",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_is_approved({args: paramByName, ...options}) as RTNftIsApproved 
    }

    return (this.contract as any).nft_is_approved(paramByName) as RTNftIsApproved 
    
  }
  
}
export default NftStandard;
