
// Code generated by zane generator DO NOT EDIT.
import { RequestManager, PostMessageWindowTransport, PostMessageIframeTransport, WebSocketTransport, HTTPTransport, Client, JSONRPCError } from "@open-rpc/client-js";
import _ from "lodash";
import { OpenrpcDocument as OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator, MethodNotFoundError } from "@open-rpc/schema-utils-js";
import { Account, Near, Contract} from "near-api-js";
import BN from "bn.js"

/**
 *
 * Token identifier that corresponds to an id
 *
 */
export type TokenId = string;
export type FtMetadataName = string;
/**
 *
 * URL to an off-chain JSON file with more info.
 *
 */
export type FTMetadataReference = string;
/**
 *
 * Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
 *
 */
export type FTMetadataReferenceHash = string;
/**
 *
 * ex. MOCHI
 *
 */
export type FTMetadataSymbol = string;
/**
 *
 * number of decimals for the token useful for FT related tokens
 *
 */
export type FTMetadataDecimals = number;
/**
 *
 * Version of token typically x.x.x major.minor.patch
 *
 */
export type FTMetadataVersion = string;
/**
 *
 * U128 integer as string
 *
 */
export type U128 = string;
export type BooleanVyG3AETh = boolean;
/**
 *
 * AccountId for the near account
 *
 */
export type AccountId = string;
/**
 *
 * A message to describe an operation
 *
 */
export type Memo = string;
export type TokenIds = [TokenId];
export type NullQu0Arl1F = null;
export interface FTMetadata {
  name: FtMetadataName;
  reference: FTMetadataReference;
  reference_hash: FTMetadataReferenceHash;
  symbol: FTMetadataSymbol;
  decimals: FTMetadataDecimals;
  version: FTMetadataVersion;
  [k: string]: any;
}
export interface StorageBalanceBoundsObject {
  min?: U128;
  max?: U128;
  [k: string]: any;
}
export interface StorageBalance {
  total: U128;
  available: U128;
  [k: string]: any;
}
export type UnorderedSetOfBooleanVyG3AETheht2BVDp = [BooleanVyG3AETh];
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */
export type AnyOfAccountIdU128MemoAccountIdU128MemoAccountIdAccountIdAccountIdBooleanVyG3AEThBooleanVyG3AEThTokenIdsU128NullQu0Arl1FU128U128U128FTMetadataStorageBalanceBoundsObjectStorageBalanceStorageBalanceUnorderedSetOfBooleanVyG3AETheht2BVDpStorageBalance = AccountId | U128 | Memo | BooleanVyG3AETh | TokenIds | NullQu0Arl1F | FTMetadata | StorageBalanceBoundsObject | StorageBalance | UnorderedSetOfBooleanVyG3AETheht2BVDp;
export type FtTransfer = (receiver_id: AccountId, amount: U128, memo?: Memo) => Promise<NullQu0Arl1F>;
export type FtTransferCall = (receiver_id: AccountId, amount: U128, memo?: Memo) => Promise<U128>;
export type FtBalanceOf = (account_id: AccountId) => Promise<U128>;
export type FtTotalSupply = () => Promise<U128>;
export type FtMetadata = () => Promise<FTMetadata>;
export type StorageBalanceBounds = () => Promise<StorageBalanceBoundsObject>;
export type StorageBalanceOf = (account_id: AccountId) => Promise<StorageBalance>;
export type StorageDeposit = (account_id?: AccountId, registration_only?: BooleanVyG3AETh) => Promise<StorageBalance>;
export type StorageUnregister = (force?: BooleanVyG3AETh) => Promise<UnorderedSetOfBooleanVyG3AETheht2BVDp>;
export type StorageWithdraw = (token_ids: TokenIds, amount: U128) => Promise<StorageBalance>;

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTFtTransfer = [...Parameters<FtTransfer>, ChangeMethodOptions?]
  type RTFtTransfer = ReturnType<FtTransfer>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTFtTransferCall = [...Parameters<FtTransferCall>, ChangeMethodOptions?]
  type RTFtTransferCall = ReturnType<FtTransferCall>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTFtBalanceOf = [...Parameters<FtBalanceOf>, ChangeMethodOptions?]
  type RTFtBalanceOf = ReturnType<FtBalanceOf>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTFtTotalSupply = [...Parameters<FtTotalSupply>, ChangeMethodOptions?]
  type RTFtTotalSupply = ReturnType<FtTotalSupply>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTFtMetadata = [...Parameters<FtMetadata>, ChangeMethodOptions?]
  type RTFtMetadata = ReturnType<FtMetadata>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageBalanceBounds = [...Parameters<StorageBalanceBounds>, ChangeMethodOptions?]
  type RTStorageBalanceBounds = ReturnType<StorageBalanceBounds>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageBalanceOf = [...Parameters<StorageBalanceOf>, ChangeMethodOptions?]
  type RTStorageBalanceOf = ReturnType<StorageBalanceOf>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageDeposit = [...Parameters<StorageDeposit>, ChangeMethodOptions?]
  type RTStorageDeposit = ReturnType<StorageDeposit>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageUnregister = [...Parameters<StorageUnregister>, ChangeMethodOptions?]
  type RTStorageUnregister = ReturnType<StorageUnregister>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageWithdraw = [...Parameters<StorageWithdraw>, ChangeMethodOptions?]
  type RTStorageWithdraw = ReturnType<StorageWithdraw>


export interface Options {
    account: Account;
    contractId: string;
}

export type NearNumber = BN | string | number;

export interface ChangeMethodOptions {
  gas?: NearNumber 
  amount?: NearNumber
}

const isMetaObject = (x: any): boolean => {
  if(x && (x.gas || x.amount)) return true
  return false
}

export class FTStandard {
  public static openrpcDocument: OpenRPC = {"openrpc":"1.0.0","info":{"title":"FTStandard","version":"0.0.0-development"},"methods":[{"name":"ft_transfer","summary":"Transfers tokens from one account to another","description":"Transfer tokens from one account to another. A basic token transfer.","tags":[{"name":"change","description":"change method"}],"params":[{"name":"receiver_id","summary":"Receiving account id","description":"The valid NEAR account receiving the token","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"amount","summary":"The amount of tokens to transfer for token_id","description":"The amount of tokens to transfer for token_id. The amount of tokens to transfer must be 1 or greater","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true},{"name":"memo","summary":"Memo message to describe operation","description":"For use cases that may benefit from indexing or providing information for a transfer","schema":{"title":"Memo","description":"A message to describe an operation","type":"string"},"required":false}],"result":{"name":"FtTransferResult","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"ft_transfer_call","description":"Transfer tokens from one account to another contract. Transfer token/s and call a method on a receiver contract. A successful workflow will end in a success execution outcome to the callback on the MultiToken contract at the method `mt_resolve_transfer`. You can think of this as being similar to attaching NEAR tokens as a `deposit` to a function call. It allows you to attach any FungibleToken or NonFungibleToken in a call to a receiver contract.  ","summary":"Transfers tokens from one account to another contract","tags":[{"name":"change","description":"change method"}],"params":[{"name":"receiver_id","summary":"Receiving account id","description":"The valid NEAR account receiving the token","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"amount","summary":"The amount of tokens to transfer","description":"The amount of tokens to transfer","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true},{"name":"memo","summary":"Memo message to describe operation","description":"For use cases that may benefit from indexing or providing information for a transfer","schema":{"title":"Memo","description":"A message to describe an operation","type":"string"},"required":false}],"result":{"name":"FtTransferCallResult","summary":"The amount optionally returned to sender","description":"The amount returned to the sender, if resolve implmented","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":false}},{"name":"ft_balance_of","summary":"Get the balance of an account id for the contract","description":"Get the balance of an account id for the contract","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"account_id","summary":"Account id to get the balance of","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"}}],"result":{"name":"FtBalanceOfResult","schema":{"title":"U128","type":"string","description":"U128 integer as string"}}},{"name":"ft_total_supply","summary":"Get the total supply of tokens in the contract","description":"Get the total supply of tokens in the contract","tags":[{"name":"view","description":"View only methods"}],"params":[],"result":{"name":"FtTotalSupplyResult","schema":{"title":"U128","type":"string","description":"U128 integer as string"}}},{"name":"ft_metadata","summary":"Get the metadata for the contract","description":"Get the metadata for the contract","tags":[{"name":"view","description":"View only methods"}],"params":[],"result":{"name":"FtMetadataResult","schema":{"title":"FTMetadata","type":"object","properties":{"name":{"title":"FtMetadataName","type":"string"},"reference":{"type":"string","title":"FTMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"FTMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."},"symbol":{"title":"FTMetadataSymbol","type":"string","description":"ex. MOCHI"},"decimals":{"title":"FTMetadataDecimals","type":"integer","description":"number of decimals for the token useful for FT related tokens"},"version":{"title":"FTMetadataVersion","type":"string","description":"Version of token typically x.x.x major.minor.patch"}},"required":["version","name","symbol","reference","reference_hash","decimals"]}}},{"name":"storage_balance_bounds","summary":"Returns the minimum and maximum allowe balance amounts to interact with this contract","description":"Returns the minimum and maximum allowe balance amounts to interact with this contract","tags":[{"name":"view","description":"View only methods"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[],"result":{"name":"StorageBalanceBoundsResult","summary":"min` is the amount of tokens required to start","description":"This will  be returned for the method `storage_balance_bounds`. Both `min` and `max` are string representations of unsigned 128-bit integers.`min` is the amount of tokens required to start using this contract at all (eg to register with the contract). If a new contract user attaches `min` NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of` for this user must show their `total` equal to `min` and `available=0` .  A contract may implement `max` equal to `min` if it only charges for initial registration, and does not adjust per-user storage over time. A contract which implements `max` must refund deposits that would increase a user's storage balance beyond this amount.","schema":{"title":"StorageBalanceBoundsObject","type":"object","properties":{"min":{"title":"U128","type":"string","description":"U128 integer as string"},"max":{"title":"U128","type":"string","description":"U128 integer as string"}}}}},{"name":"storage_balance_of","summary":"Returns the storage balance of an account for set of token_ids","description":"Returns the storage balance of an account for set of token_ids. If the `account_id` is not registered it will return `null`","tags":[{"name":"view","description":"View only methods"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"account_id","summary":"Account to allocate storage for","description":"Account to allocate storage for","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true}],"result":{"name":"StorageBalanceOfResult","summary":"Storage balance of the `account_id`","description":"Storage balance of the `account_id`","schema":{"title":"StorageBalance","type":"object","properties":{"total":{"title":"U128","type":"string","description":"U128 integer as string"},"available":{"title":"U128","type":"string","description":"U128 integer as string"}},"required":["total","available"]},"required":false}},{"name":"storage_deposit","summary":"Payable method that receives an attached deposit of Ⓝ for a given account","description":"Payable method that receives an attached deposit of Ⓝ for a given account. ","tags":[{"name":"change","description":"change method"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"account_id","summary":"Account to allocate storage for","description":"Account to allocate storage for","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":false},{"name":"registration_only","summary":"Registration flag that if true will refund above minimum balance if accound didn't exist and full deposit if it exists.","description":"Registration flag that if true will refund above minimum balance if accound didn't exist and full deposit if it exists.","schema":{"type":"boolean","title":"boolean_vyG3AETh"},"required":false}],"result":{"name":"StorageDepositResult","summary":"Returns the `StorageBalance` showing updated balances","description":"Returns the `StorageBalance` showing updated balances","schema":{"title":"StorageBalance","type":"object","properties":{"total":{"title":"U128","type":"string","description":"U128 integer as string"},"available":{"title":"U128","type":"string","description":"U128 integer as string"}},"required":["total","available"]}}},{"name":"storage_unregister","summary":"Unregister the predecessor account and return the storage NEAR deposit back","description":"Unregister the predecessor account and return the storage NEAR deposit back. Requires 1yoctoNEAR attached balance to prevent function-call access-key call","tags":[{"name":"change","description":"change method"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"force","summary":"The force flag set to true will ignore account balances and burn the tokens and close the account","description":"The force flag set to true will ignore account balances and burn the tokens and close the account","schema":{"type":"boolean","title":"boolean_vyG3AETh"},"required":false}],"result":{"name":"StorageUnregisterResult","summary":"An array of booleans corresponding to the `token_ids`. `false` if token was already unregistered true other wise","schema":{"type":"array","items":[{"type":"boolean","title":"boolean_vyG3AETh"}],"title":"unorderedSetOf_boolean_vyG3AETheht2bVDp"}}},{"name":"storage_withdraw","summary":"Withdraw specified amount of available Ⓝ for predecessor account.","description":"Withdraw specified amount of available Ⓝ for predecessor account. ","tags":[{"name":"change","description":"change method"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"token_ids","summary":"The tokens to withdraw storage from","description":"The tokens to withdraw storage from","schema":{"title":"TokenIds","type":"array","items":[{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}]}},{"name":"amount","summary":"The amount of balance to refund","description":"The amount of balance to refund, if not specified then it's the total amount. Must require exactly 1 yoctoNEAR attached balance to prevent restricted function-call access-key call for wallet security.","schema":{"title":"U128","type":"string","description":"U128 integer as string"}}],"result":{"name":"StorageWithdrawResult","summary":"Returns the StorageBalance structure showing updated balances","schema":{"title":"StorageBalance","type":"object","properties":{"total":{"title":"U128","type":"string","description":"U128 integer as string"},"available":{"title":"U128","type":"string","description":"U128 integer as string"}},"required":["total","available"]},"required":true}}]} ;
  public contract: Contract;
  private validator: MethodCallValidator;

  constructor(options: Options) {
    const {account, contractId} = options;
    this.validator = new MethodCallValidator(FTStandard.openrpcDocument);
    const changeMethods:string[] = [
      "ft_transfer",
      "ft_transfer_call",
      "storage_deposit",
      "storage_unregister",
      "storage_withdraw",
    ] 

    const viewMethods:string[] = [
      "ft_balance_of",
      "ft_total_supply",
      "ft_metadata",
      "storage_balance_bounds",
      "storage_balance_of",
    ]
    this.contract = new Contract(account,contractId, {changeMethods, viewMethods})
  }

  

  /**
   * Transfers tokens from one account to another
   * 
   */
  // tslint:disable-next-line:max-line-length
  public ft_transfer(receiver_id: AccountId, amount: U128, memo?: Memo, options?: ChangeMethodOptions): RTFtTransfer { 
    //return this.request("ft_transfer", params);
    const paramNames:string[] = [  
      "receiver_id", 
      "amount", 
      "memo",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).ft_transfer({args: paramByName, ...options}) as RTFtTransfer 
    }

    return (this.contract as any).ft_transfer({args: paramByName}) as RTFtTransfer 
  }
  

  /**
   * Transfers tokens from one account to another contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public ft_transfer_call(receiver_id: AccountId, amount: U128, memo?: Memo, options?: ChangeMethodOptions): RTFtTransferCall { 
    //return this.request("ft_transfer_call", params);
    const paramNames:string[] = [  
      "receiver_id", 
      "amount", 
      "memo",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).ft_transfer_call({args: paramByName, ...options}) as RTFtTransferCall 
    }

    return (this.contract as any).ft_transfer_call({args: paramByName}) as RTFtTransferCall 
  }
  

  /**
   * Get the balance of an account id for the contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public ft_balance_of(account_id: AccountId): RTFtBalanceOf { 
    //return this.request("ft_balance_of", params);
    const paramNames:string[] = [  
      "account_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).ft_balance_of({args: paramByName, ...options}) as RTFtBalanceOf 
    }

    return (this.contract as any).ft_balance_of(paramByName) as RTFtBalanceOf 
    
  }
  

  /**
   * Get the total supply of tokens in the contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public ft_total_supply(): RTFtTotalSupply { 
    //return this.request("ft_total_supply", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).ft_total_supply({args: paramByName, ...options}) as RTFtTotalSupply 
    }

    return (this.contract as any).ft_total_supply(paramByName) as RTFtTotalSupply 
    
  }
  

  /**
   * Get the metadata for the contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public ft_metadata(): RTFtMetadata { 
    //return this.request("ft_metadata", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).ft_metadata({args: paramByName, ...options}) as RTFtMetadata 
    }

    return (this.contract as any).ft_metadata(paramByName) as RTFtMetadata 
    
  }
  

  /**
   * Returns the minimum and maximum allowe balance amounts to interact with this contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_balance_bounds(): RTStorageBalanceBounds { 
    //return this.request("storage_balance_bounds", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_balance_bounds({args: paramByName, ...options}) as RTStorageBalanceBounds 
    }

    return (this.contract as any).storage_balance_bounds(paramByName) as RTStorageBalanceBounds 
    
  }
  

  /**
   * Returns the storage balance of an account for set of token_ids
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_balance_of(account_id: AccountId): RTStorageBalanceOf { 
    //return this.request("storage_balance_of", params);
    const paramNames:string[] = [  
      "account_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_balance_of({args: paramByName, ...options}) as RTStorageBalanceOf 
    }

    return (this.contract as any).storage_balance_of(paramByName) as RTStorageBalanceOf 
    
  }
  

  /**
   * Payable method that receives an attached deposit of Ⓝ for a given account
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_deposit(account_id?: AccountId, registration_only?: BooleanVyG3AETh, options?: ChangeMethodOptions): RTStorageDeposit { 
    //return this.request("storage_deposit", params);
    const paramNames:string[] = [  
      "account_id", 
      "registration_only",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_deposit({args: paramByName, ...options}) as RTStorageDeposit 
    }

    return (this.contract as any).storage_deposit({args: paramByName}) as RTStorageDeposit 
  }
  

  /**
   * Unregister the predecessor account and return the storage NEAR deposit back
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_unregister(force?: BooleanVyG3AETh, options?: ChangeMethodOptions): RTStorageUnregister { 
    //return this.request("storage_unregister", params);
    const paramNames:string[] = [  
      "force",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_unregister({args: paramByName, ...options}) as RTStorageUnregister 
    }

    return (this.contract as any).storage_unregister({args: paramByName}) as RTStorageUnregister 
  }
  

  /**
   * Withdraw specified amount of available Ⓝ for predecessor account.
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_withdraw(token_ids: TokenIds, amount: U128, options?: ChangeMethodOptions): RTStorageWithdraw { 
    //return this.request("storage_withdraw", params);
    const paramNames:string[] = [  
      "token_ids", 
      "amount",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_withdraw({args: paramByName, ...options}) as RTStorageWithdraw 
    }

    return (this.contract as any).storage_withdraw({args: paramByName}) as RTStorageWithdraw 
  }
  
}
export default FTStandard;
